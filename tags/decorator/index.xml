<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>decorator on Python Study</title><link>https://python.study/tags/decorator/</link><description>Recent content in decorator on Python Study</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 04 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://python.study/tags/decorator/index.xml" rel="self" type="application/rss+xml"/><item><title>Subtle Aspects of Python's Generator Function</title><link>https://python.study/p/subtle-aspects-of-pythons-generator-function/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/subtle-aspects-of-pythons-generator-function/</guid><description>&lt;img src="https://python.study/p/subtle-aspects-of-pythons-generator-function/cover.jpeg" alt="Featured image of post Subtle Aspects of Python's Generator Function" />Any function in Python that contains the keyword yield is called a generator function. When called, a generator function returns a generator object that &amp;ldquo;wraps&amp;rdquo; the body of the function. When an object of the generator is passed to the next() function, execution continues until the next yield statement in the function body, and the value associated with that yield is returned. When the function exits, the generator object raises a StopIteration exception according to the Iterator protocol.</description></item><item><title>Function Overloading in Python</title><link>https://python.study/p/function-overloading-in-python/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/function-overloading-in-python/</guid><description>&lt;img src="https://python.study/p/function-overloading-in-python/cover.jpeg" alt="Featured image of post Function Overloading in Python" />Function overloading is a mechanism in C++ that allows defining functions with the same name but different parameter sets. The compiler chooses the appropriate function based on the parameters. Each function can be adapted to work with specific parameter types.
Here&amp;rsquo;s an example of declaring overloaded functions in C++:
// Prototype three write functions. int write(std::string s); // Write a string. int write(double d); // Write a double. int write(double d, int p); // Write a double with a given precision.</description></item><item><title>Parameterized Decorators</title><link>https://python.study/p/parameterized-decorators/</link><pubDate>Tue, 16 May 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/parameterized-decorators/</guid><description>&lt;img src="https://python.study/p/parameterized-decorators/cover.jpeg" alt="Featured image of post Parameterized Decorators" />In Python, decorators are a way to modify the behavior of a function without changing its source code. They are a powerful tool that can add extra functionality to your code.
def add_two(func): def wrapper(*args, **kwargs): num = func(*args, **kwargs) return num + 2 return wrapper @add_two def get_num(): return 10 print(get_num()) # The result will be 12 The first example shows how you can use a simple decorator to add extra functionality to a function.</description></item></channel></rss>