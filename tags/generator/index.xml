<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>generator on Python Study</title><link>https://python.study/tags/generator/</link><description>Recent content in generator on Python Study</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 04 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://python.study/tags/generator/index.xml" rel="self" type="application/rss+xml"/><item><title>Subtle Aspects of Python's Generator Function</title><link>https://python.study/p/subtle-aspects-of-pythons-generator-function/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/subtle-aspects-of-pythons-generator-function/</guid><description>&lt;img src="https://python.study/p/subtle-aspects-of-pythons-generator-function/cover.jpeg" alt="Featured image of post Subtle Aspects of Python's Generator Function" />Any function in Python that contains the keyword yield is called a generator function. When called, a generator function returns a generator object that &amp;ldquo;wraps&amp;rdquo; the body of the function. When an object of the generator is passed to the next() function, execution continues until the next yield statement in the function body, and the value associated with that yield is returned. When the function exits, the generator object raises a StopIteration exception according to the Iterator protocol.</description></item><item><title>Generator Expressions</title><link>https://python.study/p/generator-expressions/</link><pubDate>Sun, 14 May 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/generator-expressions/</guid><description>&lt;img src="https://python.study/p/generator-expressions/cover.jpeg" alt="Featured image of post Generator Expressions" />Generator Expressions (genexp) in Python allow you to iterate over elements one at a time without creating a full list in memory. This is useful when you only need to iterate over the elements and don&amp;rsquo;t need to store them in memory. By doing so, you can conserve memory and improve performance.
For example, let&amp;rsquo;s compare these two code snippets:
sum([x*x for x in range(100_000_000)]) sum(x*x for x in range(100_000_000)) In the first case, a list is created using list comprehensions PEP 202.</description></item></channel></rss>