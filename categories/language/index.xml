<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Language on Python Study</title><link>https://python.study/categories/language/</link><description>Recent content in Language on Python Study</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 04 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://python.study/categories/language/index.xml" rel="self" type="application/rss+xml"/><item><title>Subtle Aspects of Python's Generator Function</title><link>https://python.study/p/subtle-aspects-of-pythons-generator-function/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/subtle-aspects-of-pythons-generator-function/</guid><description>&lt;img src="https://python.study/p/subtle-aspects-of-pythons-generator-function/cover.jpeg" alt="Featured image of post Subtle Aspects of Python's Generator Function" />Any function in Python that contains the keyword yield is called a generator function. When called, a generator function returns a generator object that &amp;ldquo;wraps&amp;rdquo; the body of the function. When an object of the generator is passed to the next() function, execution continues until the next yield statement in the function body, and the value associated with that yield is returned. When the function exits, the generator object raises a StopIteration exception according to the Iterator protocol.</description></item><item><title>Don't forget about __slots__ in Python!</title><link>https://python.study/p/dont-forget-about-slots-in-python/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/dont-forget-about-slots-in-python/</guid><description>&lt;img src="https://python.study/p/dont-forget-about-slots-in-python/cover.jpeg" alt="Featured image of post Don't forget about __slots__ in Python!" />Python&amp;rsquo;s __slots__ is a simple yet powerful feature that is often overlooked and misunderstood by many. By default, Python stores instance attributes in a dictionary called __dict__ that belongs to the instance itself. This common approach is associated with significant overhead. However, this behavior can be altered by defining a class attribute called __slots__.
When __slots__ is defined, Python uses an alternative storage model for instance attributes: the attributes are stored in a hidden array of references, which consumes significantly less memory than a dictionary.</description></item><item><title>Exploring Python Collections with ABC and Goose Typing</title><link>https://python.study/p/exploring-python-collections-with-abc-goose-typing/</link><pubDate>Wed, 12 Jul 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/exploring-python-collections-with-abc-goose-typing/</guid><description>&lt;img src="https://python.study/p/exploring-python-collections-with-abc-goose-typing/cover.jpeg" alt="Featured image of post Exploring Python Collections with ABC and Goose Typing" />Python&amp;rsquo;s Abstract Base Classes (ABCs) in the collections.abc module are a set of tools that help us check if a class follows a specific interface. This is done using the issubclass() or isinstance() functions. The interesting part is that the class we&amp;rsquo;re checking doesn&amp;rsquo;t need to inherit from the abstract base type. It just needs to provide the necessary methods to match the abstract type.
Here&amp;rsquo;s an example:
from collections.abc import Iterable class MyClass: def __iter__(self): .</description></item><item><title>String methods to remove prefixes and suffixes</title><link>https://python.study/p/string-methods-to-remove-prefixes-suffixes/</link><pubDate>Wed, 31 May 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/string-methods-to-remove-prefixes-suffixes/</guid><description>&lt;img src="https://python.study/p/string-methods-to-remove-prefixes-suffixes/cover.jpeg" alt="Featured image of post String methods to remove prefixes and suffixes" />Python 3.9 introduced two new string methods, removeprefix() and removesuffix(), for various string objects. These methods remove a prefix or suffix (respectively) from a string, if present. The reason for adding these two new methods is that the existing methods, str.lstrip and str.rstrip, often confuse users. These methods remove leading or trailing characters, not substrings. This can lead to unintended removal of useful data.
For example, consider the following code:</description></item><item><title>Union Type Expression</title><link>https://python.study/p/union-type-expr-in-python/</link><pubDate>Mon, 29 May 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/union-type-expr-in-python/</guid><description>&lt;img src="https://python.study/p/union-type-expr-in-python/cover.jpeg" alt="Featured image of post Union Type Expression" />Starting from Python 3.10, you can use Union type expression in some scenarios.
The built-in functions isinstance() and issubclass() take a type or tuple of types as their second argument. Using tuples requires writing additional parentheses.
Consider the code below:
x = 42 print(isinstance(x, (int, str))) # output: True print(issubclass(type(x), (int, str))) # output: True Let&amp;rsquo;s rewrite this example using Union type expression:
x = 42 print(isinstance(x, int | str)) # output: True print(issubclass(type(x), int | str)) # output: True This example is equivalent to the previous one, but it looks cleaner.</description></item><item><title>Keyword-Only and Positional-Only Parameters in Function</title><link>https://python.study/p/keyword-and-positional-only-params-in-func/</link><pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/keyword-and-positional-only-params-in-func/</guid><description>&lt;img src="https://python.study/p/keyword-and-positional-only-params-in-func/cover.jpeg" alt="Featured image of post Keyword-Only and Positional-Only Parameters in Function" />In Python, function parameters can be Positional-Only, Positional-or-Keyword, or Keyword-Only. Let&amp;rsquo;s consider all three cases in the example function f:
def f(pos1, pos2, /, pos_or_kwd1, pos_or_kwd2=None, *, kwd1, kwd2): &amp;#34;&amp;#34;&amp;#34; pos1, pos2 - are Positional-Only pos_or_kwd1, pos_or_kwd2 - are Positional-or-Keyword kwd1, kwd2 - are Keyword-Only &amp;#34;&amp;#34;&amp;#34; pass The rules for defining these parameters are straightforward:
Everything before the / symbol is Positional-Only parameters. Everything after the * symbol is Keyword-Only parameters.</description></item><item><title>Python Variable Scopes: Understanding Local, Global, and Nonlocal</title><link>https://python.study/p/variable-scopes-local-global-nonlocal/</link><pubDate>Sun, 21 May 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/variable-scopes-local-global-nonlocal/</guid><description>&lt;img src="https://python.study/p/variable-scopes-local-global-nonlocal/cover.jpeg" alt="Featured image of post Python Variable Scopes: Understanding Local, Global, and Nonlocal" />In Python, there are three variable scopes: global, local, and nonlocal.
Local scope Local scope refers to variables inside a function that can only be accessed within that function. Control blocks like if, while, and for do not create a new local scope. Variables inside them belong to the enclosing function.
def local_scope(): if True: x = &amp;#39;x&amp;#39; print(f&amp;#39;{x} is local&amp;#39;) # outputs `x is local` print(f&amp;#39;{x} is local&amp;#39;) # raises NameError: name &amp;#39;x&amp;#39; is not defined Global scope Global scope refers to variables declared outside functions that can be accessed throughout the program.</description></item><item><title>Parameterized Decorators</title><link>https://python.study/p/parameterized-decorators/</link><pubDate>Tue, 16 May 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/parameterized-decorators/</guid><description>&lt;img src="https://python.study/p/parameterized-decorators/cover.jpeg" alt="Featured image of post Parameterized Decorators" />In Python, decorators are a way to modify the behavior of a function without changing its source code. They are a powerful tool that can add extra functionality to your code.
def add_two(func): def wrapper(*args, **kwargs): num = func(*args, **kwargs) return num + 2 return wrapper @add_two def get_num(): return 10 print(get_num()) # The result will be 12 The first example shows how you can use a simple decorator to add extra functionality to a function.</description></item><item><title>Union Operators To dict</title><link>https://python.study/p/union-operators-to-dict/</link><pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/union-operators-to-dict/</guid><description>&lt;img src="https://python.study/p/union-operators-to-dict/cover.jpeg" alt="Featured image of post Union Operators To dict" />Let&amp;rsquo;s take a look at the new operators for dict that appeared in Python 3.9 - merge (|) and update (|=) operators.
The current ways to merge two dicts have several disadvantages:
dict.update d1.update(d2) modifies d1 in-place.
e = d1.copy(); e.update(d2) is not an expression and needs a temporary variable.
{**d1, **d2} Dict unpacking looks ugly and is not easily discoverable. Few people would be able to guess what it means the first time they see it, or think of it as the &amp;ldquo;obvious way&amp;rdquo; to merge two dicts.</description></item><item><title>Generator Expressions</title><link>https://python.study/p/generator-expressions/</link><pubDate>Sun, 14 May 2023 00:00:00 +0000</pubDate><guid>https://python.study/p/generator-expressions/</guid><description>&lt;img src="https://python.study/p/generator-expressions/cover.jpeg" alt="Featured image of post Generator Expressions" />Generator Expressions (genexp) in Python allow you to iterate over elements one at a time without creating a full list in memory. This is useful when you only need to iterate over the elements and don&amp;rsquo;t need to store them in memory. By doing so, you can conserve memory and improve performance.
For example, let&amp;rsquo;s compare these two code snippets:
sum([x*x for x in range(100_000_000)]) sum(x*x for x in range(100_000_000)) In the first case, a list is created using list comprehensions PEP 202.</description></item></channel></rss>